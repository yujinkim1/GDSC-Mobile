# GDSC-Mobile-Study - 1.1 (Built-in types, Functions)
## ê¹€í•˜ì€

# ê³µë¶€í•œ ë‚´ìš©
##Built-in types
- int, double
```dart
// int
var a = 1;
var hex = 0xDEADBEEF;

// double
var b = 1;
var exponents = 1.42e5;

// ë³€ìˆ˜ë¥¼ ìˆ«ìë¡œ ì„ ì–¸
num x = 1;
x += 2.5;

// ì •ìˆ˜ ë¦¬í„°ëŸ´ì€ ìë™ìœ¼ë¡œ doubleë¡œ ë³€í™˜ë¨.
double z = 1;

// String to int (ë¬¸ìì—´ì„ ìˆ«ìë¡œ ë°”ê¾¸ê¸°)
var one = int.parse('1');
assert(one == 1);

// int to String (ìˆ«ìë¥¼ ë¬¸ìì—´ë¡œ ë°”ê¾¸ê¸°)
String oneAsString = 1.toString();
assert(oneAsString == '1');

// ë¹„íŠ¸ ì‹œí”„íŠ¸( <<, >>, >>>), ë³´ìˆ˜( ~), AND( &), OR( |) ë° XOR( ) ì—°ì‚°ìë¥¼ ì§€ì •í•¨.
assert ((3 << 1) == 6);     // 0011 << 1 == 0110
```
- String
```dart
// ì„ ì–¸
var s1 = 'Hello World!';

// ê°ì²´ì— í•´ë‹¹í•˜ëŠ” ë¬¸ìì—´ì„ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ê°ì²´ì˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œ
var s = 'Hi';
assert('Hello or $s' == 'Hello or Hi');
assert('Hello or ${s.toUpperCase()}' == 'Hello or HI');

// ì¸ì ‘í•œ ë¬¸ìì—´ì€ '+'ì—°ì‚°ìë¡œ ë¬¸ìì—´ì„ ì—°ê²°í•  ìˆ˜ ìˆìŒ.
var s1 = 'A '
    'BBB'
    "C";
assert(s1 ==
    'ABB'
    'BC');
var s2 = 'The + operator ' + 'works, as well.';
assert(s2 == 'The + operator works, as well.');

// ì—¬ëŸ¬ ì¤„ ë¬¸ìì—´ì„ ë§Œë“¤ ë•Œ ì‚¼ì¤‘ ë”°ì˜´í‘œë¥¼ ì‚¬ìš©í•¨.
var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";
```

- Bool
```dart
// true, false ê°’ ì‚¬ìš©
// if (nonbooleanValue) or assert(nonbooleanValue)ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ.
var fullName = '';
assert(fullName.isEmpty);       // stringì´ ë¹„ì–´ ìˆëŠ”ì§€ í™•ì¸í•¨.
```

- List
```dart
// ë°°ì—´ ì„ ì–¸
var list1 = [1, 2, 3];

var list2 = [
  'Car',
  'Boat',
  'Plane',
];

// 0ë¶€í„° ì¸ë±ì‹±í•œë‹¤.
var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1] == 2);

// ìƒìˆ˜ì¸ ë°°ì—´ì„ ë§Œë“¤ë ¤ë©´ constë¥¼ ì¶”ê°€í•¨.
var constantList = const [1, 2, 3];

// ì—¬ëŸ¬ ê°’ì„ ì‚½ì…í•˜ëŠ” ê°„ê²°í•œ ë°©ë²• -> ... ì‚¬ìš©í•˜ê¸°
var list = [1, 2, 3];
var list2 = [0, ...list];
assert(list2.length == 4);

// null ì¸ì‹ ìŠ¤í”„ë ˆë“œ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
var list2 = [0, ...?list];
assert(list2.length == 1);
```

- Set
```dart
// ì§‘í•© ì„ ì–¸
var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};

// ë¹„ì–´ìˆëŠ” ì§‘í•© ì„ ì–¸
var names = <String>{};

// add(), addAll()ë¡œ í•­ëª© ì¶”ê°€
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);

// .lengthë¡œ í•­ëª©ì˜ ê°œìˆ˜ë¥¼ ê°€ì ¸ì˜´.
assert(elements.length == 5);

// ìƒìˆ˜ì¸ ì§‘í•©ì„ ë§Œë“¤ë ¤ë©´ constë¥¼ ì¶”ê°€í•¨.
final constantSet = const {
  'fluorine',
  'chlorine',
  'bromine',
  'iodine',
  'astatine',
};
```

- Map
```dart
// í‚¤ì™€ ê°’ì„ ì—°ê²°, í‚¤ í•˜ë‚˜ì— ê°’ì„ ì—¬ëŸ¬ê°œ ë„£ì„ ìˆ˜ ìˆìŒ.
var gifts = {
  // Key:    Value
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

var nobleGases = {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};

// ë™ì¼í•œ ê°ì²´ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŒ.
var gifts = Map<String, String>();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

// []= ë¥¼ ì´ìš©í•´ ê¸°ì¡´ ë§µì— ìƒˆë¡œìš´ key-value ìŒì„ ì¶”ê°€
var gifts = {'first': 'partridge'};
gifts['fourth'] = 'calling birds';

// [] ë¥¼ ì´ìš©í•´ ë§µì—ì„œ ê°’ì„ ê²€ìƒ‰
var gifts = {'first': 'partridge'};
assert(gifts['first'] == 'partridge');

// ë§µì— ì—†ëŠ” keyë¥¼ ì°¾ê²Œë˜ë©´ null
var gifts = {'first': 'partridge'};
assert(gifts['fifth'] == null);

// .lengthë¥¼ ì´ìš©í•´ key-value ìŒì˜ ìˆ˜ë¥¼ ê°€ì ¸ì˜´.
var gifts = {'first': 'partridge'};
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);

// ìƒìˆ˜ì¸ ë§µì„ ë§Œë“¤ë ¤ë©´ constë¥¼ ì¶”ê°€í•¨.
final constantMap = const {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};
```

- Runes
```dart
// ë¬¸ìì—´ì˜ ìœ ë‹ˆì½”ë“œ ì½”ë“œ í¬ì¸íŠ¸ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜
import 'package:characters/characters.dart';
...
var hi = 'Hi ğŸ‡©ğŸ‡°';
print(hi);                                                          // ì¶œë ¥ : Hi ğŸ‡©ğŸ‡°
print('The end of the string: ${hi.substring(hi.length - 1)}');     // ì¶œë ¥ : The end of the string: ???
print('The last character: ${hi.characters.last}\n');               // ì¶œë ¥ : The last character: ğŸ‡©ğŸ‡°
```

- Symbol
```dart
// ì—°ì‚°ìë‚˜ ì‹ë³„ìë¥¼ ë‚˜íƒ€ëƒ„.
// ì‹ë³„ìë¥¼ ì°¸ì¡°í•˜ëŠ” APIì—ì„œ ë§¤ìš° ì¤‘ìš”í•¨.
// ì‹ë³„ìì— ëŒ€í•œ ê¸°í˜¸ë¥¼ ê°€ì ¸ì˜¤ë ¤ë©´ #ë’¤ì— ì‹ë³„ìë¥¼ ë„£ìŒ.
#radix
#bar
```

- Object
Nullì„ ì œì™¸í•œ ëª¨ë“  Dart í´ë˜ìŠ¤ì˜ ìŠˆí¼í´ë˜ìŠ¤.

- Enum
ëª¨ë“  ì—´ê±°í˜•ì˜ ìŠˆí¼í´ë˜ìŠ¤.

- Futureë° Stream
ë¹„ë™ê¸° ì§€ì›ì— ì‚¬ìš©ë¨.

- Iterable
for-in ë£¨í”„ ë° Synchronous Generator í•¨ìˆ˜ì—ì„œ ì‚¬ìš©ë¨ .

- Never
í‘œí˜„ì‹ì´ í‰ê°€ë¥¼ ì™„ë£Œí•  ìˆ˜ ì—†ìŒì„ ë‚˜íƒ€ëƒ„. í•­ìƒ ì˜ˆì™¸ë¥¼ throwí•˜ëŠ” í•¨ìˆ˜ì— ê°€ì¥ ìì£¼ ì‚¬ìš©ë¨.

- dynamic
ì •ì  ê²€ì‚¬ë¥¼ ë¹„í™œì„±í™” í•  ê²ƒì„ì„ ë‚˜íƒ€ëƒ„. ì¼ë°˜ì ìœ¼ë¡œ Objectë‚˜ Object?ë¥¼ ì‚¬ìš©í•´ì•¼ í•¨.

- void
ê°’ì´ ì‚¬ìš©ë˜ì§€ ì•ŠìŒì„ ë‚˜íƒ€ëƒ„. ë°˜í™˜ ìœ í˜•ìœ¼ë¡œ ìì£¼ ì‚¬ìš©ë¨.

## Functions
DartëŠ” ê°ì²´ ì§€í–¥ ì–¸ì–´ì´ê¸° ë•Œë¬¸ì— í•¨ìˆ˜ë„ ê°ì²´ê³  ìœ í˜•ì´ Functionì´ë‹¤.

```dart
// í•¨ìˆ˜ êµ¬í˜„
bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}

// main() í•¨ìˆ˜ : ëª¨ë“  ì•±ì˜ ì§„ì…ì  ì—­í• ì„ í•˜ëŠ” ìµœìƒìœ„ ê¸°ëŠ¥
void main() {               // void ëŒ€í•œ ì„ íƒì  List<String>ë§¤ê°œë³€ìˆ˜ë¥¼ ë°˜í™˜í•¨.
  print('Hello, World!');
}

// '=>' í™”ì‚´í‘œ í•¨ìˆ˜ : ì½”ë“œ ë¸”ë¡ì´ í•œ ì¤„ì´ë¼ë©´ ì•½ì‹ êµ¬ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;

// first-class objectsì˜ ê¸°ëŠ¥ : í•¨ìˆ˜ë¥¼ ë‹¤ë¥¸ í•¨ìˆ˜ì— ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•  ìˆ˜ ìˆìŒ.
void printElement(int element) {
  print(element);
}
var list = [1, 2, 3];

list.forEach(printElement);

var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';      // ë³€ìˆ˜ì— í•¨ìˆ˜ë¥¼ í• ë‹¹í•  ìˆ˜ ìˆìŒ.
assert(loudify('hello') == '!!! HELLO !!!');

// ìµëª…ê¸°ëŠ¥ (Anonymous functions) : ëŒë‹¤, í´ë¡œì €ë¼ê³  í•˜ëŠ” ì´ë¦„ ì—†ëŠ” í•¨ìˆ˜(ìµëª… í•¨ìˆ˜)ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ.
const list = ['apples', 'bananas', 'oranges'];
list.forEach((item) {
  print('${list.indexOf(item)}: $item');
});

// Parameters : í•¨ìˆ˜ëŠ” í•„ìš”í•œ ìœ„ì¹˜ì— ë§¤ê°œë³€ìˆ˜ë¥¼ ì›í•˜ëŠ” ìˆ˜ë§Œí¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
// 1. required + not named parameter : í•„ìˆ˜ O + ì´ë¦„ì—†ëŠ” parameter
bool isSubject(String name) {
  return true;
}
  
isSubject("ìˆ˜í•™");
//isSubject(); ì—ëŸ¬
//isSubject(name: "ìˆ˜í•™"); ì—ëŸ¬

// ê·¸ëŸ¼ í•„ìˆ˜ O + ì´ë¦„ìˆëŠ” parameterëŠ” ì–´ë–»ê²Œ ë§Œë“œëŠ”ê°€?
bool isSubject({@required String name}) {
  assert(name != null);
  return true;
}
isFood(name: "ìˆ˜í•™");
isFood(name: null); // exception ë°œìƒ
isFood(); // exception ë°œìƒ

// 2. optional + named parameter with {} : í•„ìˆ˜ X + ì´ë¦„ìˆëŠ” parameter
bool isFood({String name}) {
  return true;
}
  
isSubject(name: "ìˆ˜í•™");
isSubject(); 
// isSubject("ìˆ˜í•™"); ì—ëŸ¬

// 3. optional + not named parameter with [] : í•„ìˆ˜ X + ì´ë¦„ì—†ëŠ” parameter
bool isFood([String name]) {
  return true;
}

isSubject();
isSubject("ìˆ˜í•™");
// isSubject(name: "ìˆ˜í•™"); ì—ëŸ¬


// parametersì˜ ê¸°ë³¸ ê°’ -> ì•„ë¬´ê°’ì´ ì—†ì„ ë•Œ nameì€ ìˆ˜í•™ì´ ë¨.
bool isSubject([String name = "ìˆ˜í•™"]) {
  return true;
}

bool isSubject({String name = "ìˆ˜í•™"}) {
  return true;
}

// Lexical scope : ë³€ìˆ˜ì˜ ë²”ìœ„ëŠ” ë‹¨ìˆœíˆ ì½”ë“œì˜ ë ˆì´ì•„ì›ƒì— ì˜í•´ ì •ì ìœ¼ë¡œ ê²°ì •ë¨.
bool topLevel = true;

void main() {
  var insideMain = true;

  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}

// Lexical closures : í´ë¡œì €ì˜ ìº¡ì³ ê¸°ëŠ¥ìœ¼ë¡œ í•¨ìˆ˜ê°€ ë²”ìœ„ ì™¸ë¶€ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê²½ìš°ì—ë„ ë³€ìˆ˜ì— ì ‘ê·¼ í•  ìˆ˜ ìˆëŠ” ê°ì²´ì„.
Function makeAdder(int addBy) {
  return (int i) => addBy + i;
}

void main() {
  var add2 = makeAdder(2);

  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}

// ìµœìƒìœ„ í•¨ìˆ˜, ì •ì  ë©”ì„œë“œ, ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œì˜ ë™ë“±ì„±ì„ í…ŒìŠ¤íŠ¸
void foo() {} // ìµœìƒìœ„ í•¨ìˆ˜

class A {
  static void bar() {}      // ì •ì  ë©”ì„œë“œ
  void baz() {}             // ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ
}

void main() {
  Function x;

  x = foo;
  assert(foo == x);     // ìµœìƒìœ„ í•¨ìˆ˜ì™€ ë¹„êµ

  x = A.bar;            // ì •ì  ë©”ì†Œë“œì™€ ë¹„êµ
  assert(A.bar == x);

  // ì¸ìŠ¤í„´ìŠ¤ ë©”ì†Œë“œì™€ ë¹„êµ
  var v = A();  // ì¸ìŠ¤í„´ìŠ¤ #1 of A
  var w = A();  // ì¸ìŠ¤í„´ìŠ¤ #2 of A
  var y = w;
  x = w.baz;

  assert(y.baz == x);

  assert(v.baz != w.baz);
}

// ë°˜í™˜ ê°’ : ëª¨ë“  í•¨ìˆ˜ëŠ” ê°’ì„ ë°˜í™˜í•˜ë©° ë°˜í™˜ ê°’ì„ ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ return null;ì´ ì•”ì‹œì ìœ¼ë¡œ í•¨ìˆ˜ì— ì¶”ê°€ë¨.
foo() {}
assert(foo() == null);
```


# ì–´ë ¤ì› ë˜ ë¶€ë¶„
ì—†ìŠµë‹ˆë‹¤.

# ê¶ê¸ˆí•œ ë¶€ë¶„
ì—†ìŠµë‹ˆë‹¤.
